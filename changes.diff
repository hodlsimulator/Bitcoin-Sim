diff --git a/BTC Simulator/ColumnsCollectionViewController.swift b/BTC Simulator/ColumnsCollectionViewController.swift
index a6989e7..31158a9 100644
--- a/BTC Simulator/ColumnsCollectionViewController.swift	
+++ b/BTC Simulator/ColumnsCollectionViewController.swift	
@@ -9,32 +9,29 @@ import UIKit
 
 class ColumnsCollectionViewController: UIViewController {
 
-    // The columns & data we want to display.
-    // PartialKeyPath so each property can be Int/Double/Decimal.
-    var allColumns: [(String, PartialKeyPath<SimulationData>)] = []
-    var displayedData: [SimulationData] = []
+    // The columns & data we want to display (PartialKeyPath so each can be Int/Double/Decimal)
+    public var allColumns: [(String, PartialKeyPath<SimulationData>)] = []
+    public var displayedData: [SimulationData] = []
 
     // For pinned-table scrolling sync
-    var onScrollSync: ((UIScrollView) -> Void)?
+    public var onScrollSync: ((UIScrollView) -> Void)?
 
-    // Optionally track a “currentActiveIndex” if needed
+    // (Optional) track a current index
     private var currentActiveIndex: Int = 0
 
-    // The collection view + a custom layout
-    private var collectionView: UICollectionView?
+    // The collection view + flow layout
+    // Renamed to avoid overshadowing dataSource func "collectionView(_:_:)"
+    public var columnsCollectionView: UICollectionView?
 
     override func viewDidLoad() {
         super.viewDidLoad()
-
         view.backgroundColor = UIColor.clear
 
         // 1) Create the layout
         let layout = UICollectionViewFlowLayout()
         layout.scrollDirection = .horizontal
 
-        // For partial columns:
-        //   - item width < screen width
-        //   - a bit of spacing so you see a “peek” of next column
+        // For partial columns, each cell narrower than screen
         layout.itemSize = CGSize(width: 240, height: view.bounds.height)
         layout.minimumLineSpacing = 10
 
@@ -42,15 +39,16 @@ class ColumnsCollectionViewController: UIViewController {
         let cv = UICollectionView(frame: .zero, collectionViewLayout: layout)
         cv.backgroundColor = .clear
         cv.showsHorizontalScrollIndicator = false
-        cv.decelerationRate = .fast       // for a snappier feel
-        cv.isPagingEnabled = false        // we want partial scroll, not full paging
+        cv.decelerationRate = .fast  // for snappier feel
+        cv.isPagingEnabled = false   // we want partial scroll, not full paging
         cv.dataSource = self
         cv.delegate = self
         cv.translatesAutoresizingMaskIntoConstraints = false
-        self.collectionView = cv
 
-        view.addSubview(cv)
+        // Store in our public var
+        self.columnsCollectionView = cv
 
+        view.addSubview(cv)
         NSLayoutConstraint.activate([
             cv.topAnchor.constraint(equalTo: view.topAnchor),
             cv.leadingAnchor.constraint(equalTo: view.leadingAnchor),
@@ -64,15 +62,21 @@ class ColumnsCollectionViewController: UIViewController {
 
     override func viewDidAppear(_ animated: Bool) {
         super.viewDidAppear(animated)
-        // If you want to default to columns #2 and #3,
-        // you might scroll to index 2 so it’s at or near the left edge:
+        // If you want to default to columns #2 & #3:
         if allColumns.count > 2 {
             let idxPath = IndexPath(item: 2, section: 0)
-            collectionView?.scrollToItem(at: idxPath, at: .left, animated: false)
+            columnsCollectionView?.scrollToItem(at: idxPath, at: .left, animated: false)
         }
     }
+
+    /// Public method so other VCs can trigger a reload easily
+    public func reloadCollectionData() {
+        columnsCollectionView?.reloadData()
+    }
 }
 
+// MARK: - UICollectionViewDataSource & Delegate
+
 extension ColumnsCollectionViewController: UICollectionViewDataSource, UICollectionViewDelegate {
 
     func collectionView(_ collectionView: UICollectionView,
@@ -82,7 +86,7 @@ extension ColumnsCollectionViewController: UICollectionViewDataSource, UICollect
 
     func collectionView(_ collectionView: UICollectionView,
                         cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
-        
+
         guard let cell = collectionView.dequeueReusableCell(
             withReuseIdentifier: "ColumnsCollectionCell",
             for: indexPath
@@ -97,9 +101,12 @@ extension ColumnsCollectionViewController: UICollectionViewDataSource, UICollect
             displayedData: displayedData
         )
 
+        // If you want vertical scroll sync:
+        cell.onScroll = { [weak self] scrollView in
+            // Pass up to pinned table
+            self?.onScrollSync?(scrollView)
+        }
+
         return cell
     }
-
-    // If you want custom spacing or sizing beyond the FlowLayout’s itemSize,
-    // implement delegateFlowLayout methods here. But the big one is itemSize.
 }
diff --git a/BTC Simulator/PinnedColumnTablesViewController.swift b/BTC Simulator/PinnedColumnTablesViewController.swift
index a065a75..8f5dc6d 100644
--- a/BTC Simulator/PinnedColumnTablesViewController.swift	
+++ b/BTC Simulator/PinnedColumnTablesViewController.swift	
@@ -18,12 +18,8 @@ class PinnedColumnTablesViewController: UIViewController {
     // Left table for the pinned (e.g. "Week") column
     let pinnedTableView = UITableView(frame: .zero, style: .plain)
     
-    // The pager on the right
-    let columnsPagerVC = ColumnsPagerViewController(
-        transitionStyle: .scroll,
-        navigationOrientation: .horizontal,
-        options: nil
-    )
+    // Now we embed our new ColumnsCollectionViewController on the right
+    private let columnsCollectionVC = ColumnsCollectionViewController()
     
     // A label/header for the pinned column
     private let pinnedHeaderLabel = UILabel()
@@ -121,17 +117,17 @@ class PinnedColumnTablesViewController: UIViewController {
             pinnedTableView.widthAnchor.constraint(equalToConstant: 70)
         ])
         
-        // 5) Add columnsPagerVC as a child
-        addChild(columnsPagerVC)
-        columnsPagerVC.view.translatesAutoresizingMaskIntoConstraints = false
-        view.addSubview(columnsPagerVC.view)
-        columnsPagerVC.didMove(toParent: self)
+        // 5) Add columnsCollectionVC as a child
+        addChild(columnsCollectionVC)
+        columnsCollectionVC.view.translatesAutoresizingMaskIntoConstraints = false
+        view.addSubview(columnsCollectionVC.view)
+        columnsCollectionVC.didMove(toParent: self)
         
         NSLayoutConstraint.activate([
-            columnsPagerVC.view.topAnchor.constraint(equalTo: headersContainer.bottomAnchor),
-            columnsPagerVC.view.leadingAnchor.constraint(equalTo: pinnedTableView.trailingAnchor),
-            columnsPagerVC.view.trailingAnchor.constraint(equalTo: view.trailingAnchor),
-            columnsPagerVC.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
+            columnsCollectionVC.view.topAnchor.constraint(equalTo: headersContainer.bottomAnchor),
+            columnsCollectionVC.view.leadingAnchor.constraint(equalTo: pinnedTableView.trailingAnchor),
+            columnsCollectionVC.view.trailingAnchor.constraint(equalTo: view.trailingAnchor),
+            columnsCollectionVC.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
         ])
         
         // pinnedTableView properties
@@ -143,27 +139,11 @@ class PinnedColumnTablesViewController: UIViewController {
         pinnedTableView.showsVerticalScrollIndicator = false
         pinnedTableView.register(PinnedColumnCell.self, forCellReuseIdentifier: "PinnedColumnCell")
 
-        // 6) When the page changes, sync scrolling & update col1/col2 titles
-        columnsPagerVC.onPageChanged = { [weak self] pageVC in
-            guard let self = self else { return }
-            
-            // Sync scroll
-            pageVC.onScroll = { [weak self] scrollView in
-                self?.syncScroll(from: scrollView, to: self?.pinnedTableView)
-            }
-            
-            // Update the two header labels
-            let cols = pageVC.columnsToShow ?? []
-            if !cols.isEmpty {
-                self.col1Label.text = cols[0].0
-            } else {
-                self.col1Label.text = nil
-            }
-            if cols.count > 1 {
-                self.col2Label.text = cols[1].0
-            } else {
-                self.col2Label.text = nil
-            }
+        // 6) Let each collection cell sync its scrolling with pinned table
+        // We'll define how in step 4 of your plan (when we build the columns collection).
+        // For now, here's a callback:
+        columnsCollectionVC.onScrollSync = { [weak self] scrollView in
+            self?.syncScroll(from: scrollView, to: self?.pinnedTableView)
         }
     }
     
@@ -179,10 +159,21 @@ class PinnedColumnTablesViewController: UIViewController {
         // Reload pinned table
         pinnedTableView.reloadData()
         
-        // Just pass partial key paths directly to the pager
-        columnsPagerVC.allColumns = rep.columns
-        columnsPagerVC.displayedData = rep.displayedData
-        columnsPagerVC.reloadPages()
+        // Pass partial key paths to the columns collection
+        columnsCollectionVC.allColumns = rep.columns
+        columnsCollectionVC.displayedData = rep.displayedData
+        
+        // Reload the collection
+        // columnsCollectionVC.collectionView?.reloadData()
+        
+        columnsCollectionVC.allColumns = rep.columns
+        columnsCollectionVC.displayedData = rep.displayedData
+        columnsCollectionVC.reloadCollectionData()
+        
+        // For sync
+        columnsCollectionVC.onScrollSync = { [weak self] scrollView in
+            self?.syncScroll(from: scrollView, to: self?.pinnedTableView)
+        }
     }
     
     // Called by parent to scroll pinned table to the bottom
@@ -194,11 +185,8 @@ class PinnedColumnTablesViewController: UIViewController {
             let pinnedPath = IndexPath(row: lastIndex, section: 0)
             pinnedTableView.scrollToRow(at: pinnedPath, at: .bottom, animated: true)
             
-            // Also scroll the active page
-            if let activePage = columnsPagerVC.currentActivePage {
-                let columnsPath = IndexPath(row: lastIndex, section: 0)
-                activePage.tableView.scrollToRow(at: columnsPath, at: .bottom, animated: true)
-            }
+            // If you'd like, you can also scroll any visible table in columnsCollectionVC
+            // But with multiple columns, you can pick a standard or skip
         }
     }
 
@@ -206,9 +194,7 @@ class PinnedColumnTablesViewController: UIViewController {
         let topIndex = IndexPath(row: 0, section: 0)
         pinnedTableView.scrollToRow(at: topIndex, at: .top, animated: true)
         
-        if let activePage = columnsPagerVC.currentActivePage {
-            activePage.tableView.scrollToRow(at: topIndex, at: .top, animated: true)
-        }
+        // Similarly, you can scroll the first visible column's table if you want
     }
     
     // Keep pinned & columns table scrolled together
@@ -275,9 +261,10 @@ extension PinnedColumnTablesViewController: UITableViewDataSource, UITableViewDe
         rep.isAtBottom = atBottom
         onIsAtBottomChanged?(atBottom)
         
-        // Sync pinned -> current columns page
-        if let activePage = columnsPagerVC.currentActivePage {
-            syncScroll(from: scrollView, to: activePage.tableView)
-        }
+        // Sync pinned -> the "current" column's table
+        // We'll just pick "some" visible column if you want.
+        // Because there's multiple columns visible at once,
+        // you'd pick the first visible cell or something similar if needed.
+        // For now, you can skip it or implement more advanced logic.
     }
 }
diff --git a/BTCMonteCarlo.xcodeproj/project.xcworkspace/xcuserdata/conor.xcuserdatad/UserInterfaceState.xcuserstate b/BTCMonteCarlo.xcodeproj/project.xcworkspace/xcuserdata/conor.xcuserdatad/UserInterfaceState.xcuserstate
index db4edd4..f3d255b 100644
Binary files a/BTCMonteCarlo.xcodeproj/project.xcworkspace/xcuserdata/conor.xcuserdatad/UserInterfaceState.xcuserstate and b/BTCMonteCarlo.xcodeproj/project.xcworkspace/xcuserdata/conor.xcuserdatad/UserInterfaceState.xcuserstate differ
